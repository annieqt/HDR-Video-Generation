bride_imgs中存放了原始实验数据，是将一个高低曝交替的连续视频每两帧拆分到一个文件夹里，一共163个文件夹。


1.  1/2MV方法。 
	假设：1.快门时间非常短，大大短于每一帧之间的间隔。
		  2.运动物体规律运动，不会在一帧时间内做大幅度运动
	分别用两种方法：
	1. 将两张低曝的图片做运动估计，得到的运动矢量再除以二，利用第一张低曝的图片作为参考帧，加1/2运动矢量，得到与高曝同一时刻拍摄的低曝图片。
	2. 将两张高曝的图片做运动估计，得到的运动矢量再除以二，利用第一张高曝的图片作为参考帧，加1/2运动矢量，得到与高曝同一时刻拍摄的低曝图片。
	在试验中，采用新娘的图片示例，其中运动部分主要在高曝图片中。


	算法主要步骤：
	1. 对每两个连续的文件夹进行计算，算出两张连续低曝图片的运动矢量
	2. 利用上一步得出的运动矢量，除以二得到补偿帧
	3. 得到一组连续的高低曝帧，高低曝可看做在同一时间拍摄
	（1~3步由demo_bride_compensated方法完成）
	4. 利用fusion方法进行合成


	

2.  bitmap结合MV方法
	bitmap算法的缺陷在于，利用一帧作为参考帧取运动部分，运动部分只来源于一种曝光度帧，所以对运动部分的要求较高，同时位于两种曝光度可能造成运动丢失。对于不同的实验数据要采用不同的参考帧。
	算法流程？打印出每一步的图，如二值图等

myestimation  
myestimation2   using2nd帧，即用第二帧（高曝）作为参考帧？
myestimation3





产物：
fusion是直接用fusion算法
myfusion是用的bitmap，其中mydetection是计算weight的方法

算法改进：得出运动矢量之后对运动不明显的像素进行舍弃